# Building a new Implementation of Muon

Muon is designed to be polyglot and has a strong concept of compatibility.

This comes from the nature of Muon libraries, which map the rich communication concepts down to particular network protocols that form the data transports. Each library can represent the concepts to the user in whatever way is deemed most appropriate for that platform. Every Muon library will communicate across particular transports in exactly the same way.

There are Muon libraries implemented in multiple languages, however not all languages! If you want to integrate with the Muon ecosystem (for example, Photon) in a natural way, and gain the greatest benefit then the most effective way is to use a Muon library.

This document describes the process to go through in order to build a new implementation of Muon.

## Introducing the Protocol Specifications

https://github.com/muoncore/muon-protocol-specifications

Compatibility between Muon implementations is enforced at the transport layer. The protocol for each transport is specified in a set of executable specifications at the above project. You will start your implementation by picking a particular transport and discovery system and implementing your new library so that it passes the specs. Once you have done so, your library is Muon compatible and will interoperate with the rest of the ecosystem.

## Design and build a language idiomatic API

A full implementation of Muon allows a user to interact with a distributed system in a way that feels natural for that environment and makes use of the idioms, features and capabilities of the language and runtime.

Part of your job as a library author is to translate the core Muon concepts and features into ones that work well in the host environment.

## Build a Discovery Implementation



## Build a CQRS style transport

## Build a Broadcast Transport

## Build a Reactive Streaming Transport

## Introspection APIs

## Codec Support
